#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 1000000
#define M 1000
#define A 5
#define NUMB_IT 15

int main (void) {


	struct timespec ts_end,ts_start;
	double time_ms;
	int i, it, kx,jx,ix, *x, *y,*p;
	/*populating arrays*/


	y=(int *) malloc(sizeof(int)*N);
	x=(int *) malloc ( sizeof(int)*N);
	p=(int *) malloc(sizeof(int)*N);
	if(p==NULL || x== NULL || y == NULL) {
		fprintf(stderr,"error allocating the vectors\n");
		exit(-1);
	}


	for(i=0;i<N;i++) {

		x[i]=3;
		y[i]=4;
	}



	/*populating array p, 1st method*/
	ix = 0;
	for (jx=0; jx < M; ++jx){
		for (kx=0; kx < M; ++kx){
			p[jx+M*kx] = ix++;
		}
	}

	time_ms=0;

	for ( it=0;it<NUMB_IT ; it++){
		if(!timespec_get(&ts_start,TIME_UTC)){
			fprintf(stderr,"error during the acquisition of start time!\n");
			exit(-1);
		}
		for (i=0; i < N; i++) {
			jx = p[i];
			y[jx] += A * x[jx];
		}
		if(!timespec_get(&ts_end, TIME_UTC)){
			fprintf(stderr,"erorr during the acquisition of end time!\n");
			exit(-1);
		}
		time_ms+=ts_end.tv_sec*1000 + ((double)ts_end.tv_nsec)/1000000 - ts_start.tv_sec*1000 - ((double)ts_start.tv_nsec)/1000000;
	}

	fprintf(stdout,"Execution time with p indexes generated by first method: %f [ms]\n",((double ) time_ms)/NUMB_IT );



	/*populating array p, 2nd method*/
	for (ix=0; ix < N; ++ix){
		p[ix] = ix;
	}

	time_ms=0;

	for ( it=0;it<NUMB_IT ; it++){
		if(!timespec_get(&ts_start,TIME_UTC)){
			fprintf(stderr,"error during the acquisition of start time!\n");
			exit(-1);
		}
		for (i=0; i < N; i++) {
			jx = p[i];
			y[jx] += A * x[jx];

		}
		if(!timespec_get(&ts_end, TIME_UTC)){
			fprintf(stderr,"erorr during the acquisition of end time!\n");
			exit(-1);
		}
		time_ms+=ts_end.tv_sec*1000 + ((double)ts_end.tv_nsec)/1000000 - ts_start.tv_sec*1000 - ((double)ts_start.tv_nsec)/1000000;
	}

	fprintf(stdout,"Execution time with p indexes generated by second method: %f [ms]\n",((double ) time_ms)/NUMB_IT );



	/*avoiding indirect addressing using index mode addressing  */
	fprintf(stdout,"--- avoiding indirect addressing ---\n");
	time_ms=0;

	ix = 0;
	for (jx=0; jx < M; ++jx){
		for (kx=0; kx < M; ++kx){
			p[jx+M*kx] = ix++;
		}
	}


	for ( it=0;it<NUMB_IT ; it++){
		if(!timespec_get(&ts_start,TIME_UTC)){
			fprintf(stderr,"error during the acquisition of start time!\n");
			exit(-1);
		}
		for (i=0; i < N; i++) {
			y[p[i]]+=A*x[p[i]];

		}
		if(!timespec_get(&ts_end, TIME_UTC)){
			fprintf(stderr,"erorr during the acquisition of end time!\n");
			exit(-1);
		}
		time_ms+=ts_end.tv_sec*1000 + ((double)ts_end.tv_nsec)/1000000 - ts_start.tv_sec*1000 - ((double)ts_start.tv_nsec)/1000000;
	}

	fprintf(stdout,"Execution time with p indexes generated by first method: %f [ms]\n",((double ) time_ms)/NUMB_IT );



	/*populating array p, 2nd method*/
	for (ix=0; ix < N; ++ix){
		p[ix] = ix;
	}

	time_ms=0;

	for ( it=0;it<NUMB_IT ; it++){
		if(!timespec_get(&ts_start,TIME_UTC)){
			fprintf(stderr,"error during the acquisition of start time!\n");
			exit(-1);
		}
		for (i=0; i < N; i++) {
			y[p[i]]+=A*x[p[i]];

		}
		if(!timespec_get(&ts_end, TIME_UTC)){
			fprintf(stderr,"erorr during the acquisition of end time!\n");
			exit(-1);
		}
		time_ms+=ts_end.tv_sec*1000 + ((double)ts_end.tv_nsec)/1000000 - ts_start.tv_sec*1000 - ((double)ts_start.tv_nsec)/1000000;
	}

	fprintf(stdout,"Execution time with p indexes generated by second method: %f [ms]\n",((double ) time_ms)/NUMB_IT );



	//Provide and benchmark an alternative implementation that accesses x and y directly, avoiding indirect addressing.
	free(x);
	free(y);
	free(p);
	return 0;
}
